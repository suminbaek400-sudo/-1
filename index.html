<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML/JS í†µí•© ëª¨ë°”ì¼ í…ŒíŠ¸ë¦¬ìŠ¤</title>
    
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #333;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            max-width: 90vw;
        }

        h1 {
            color: #00bcd4;
        }

        #tetris-canvas {
            border: 5px solid #00796b;
            background-color: #000;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        /* ì •ë³´ íŒ¨ë„ */
        #info-panel {
            display: flex;
            justify-content: space-between;
            width: 300px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        #next-piece-container {
            text-align: center;
        }

        #next-canvas {
            border: 2px solid #00796b;
            background-color: #222;
        }

        /* --- ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ --- */
        #controls {
            width: 300px;
            padding: 10px 0;
        }

        .top-row {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .bottom-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .control-btn {
            padding: 15px 10px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px #0056b3;
            transition: background-color 0.1s ease;
            flex-grow: 1; 
        }

        .control-btn:active {
            box-shadow: 0 2px #0056b3;
            transform: translateY(2px);
            background-color: #0056b3;
        }

        #btn-rotate {
            width: 100%;
            background-color: #ffc107;
            box-shadow: 0 4px #d39e00;
        }

        #btn-rotate:active {
            background-color: #d39e00;
            box-shadow: 0 2px #d39e00;
        }

        .drop-btn {
            background-color: #28a745;
            box-shadow: 0 4px #1e7e34;
        }

        .drop-btn:active {
            background-color: #1e7e34;
            box-shadow: 0 2px #1e7e34;
        }

        #game-status {
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.85);
            border-radius: 5px;
            text-align: center;
            position: absolute;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Tetris ğŸ•¹ï¸</h1>
        
        <div id="info-panel">
            <p>Score: <span id="score">0</span></p>
            <div id="next-piece-container">
                <p>Next</p>
                <canvas id="next-canvas" width="120" height="90"></canvas>
            </div>
        </div>

        <canvas id="tetris-canvas"></canvas>

        <div id="controls">
            <div class="top-row">
                <button id="btn-rotate" class="control-btn">ğŸ”„ íšŒì „</button>
            </div>
            <div class="bottom-row">
                <button id="btn-left" class="control-btn">â¬…ï¸ ì¢Œ</button>
                <button id="btn-right" class="control-btn">â¡ï¸ ìš°</button>
                <button id="btn-hard-drop" class="control-btn drop-btn">â¬‡ï¸ ë“œë¡­</button>
            </div>
        </div>

        <p id="game-status" style="display: none;">GAME OVER! F5(ìƒˆë¡œê³ ì¹¨)ë¥¼ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.</p>
    </div>

    <script>
        // --- 1. í™˜ê²½ ì„¤ì • ë° ìƒìˆ˜ ì •ì˜ ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const VACANT = '#111';

        // Canvas ì„¤ì •
        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');

        // DOM ìš”ì†Œ
        const scoreElement = document.getElementById('score');
        const statusElement = document.getElementById('game-status');

        // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
        let board = [];
        let score = 0;
        let dropStart = Date.now();
        let dropInterval = 1000;
        let currentPiece;
        let nextPiece;
        let isGameOver = false;

        // 7ê°€ì§€ í…ŒíŠ¸ë¡œë¯¸ë…¸ í˜•íƒœì™€ ìƒ‰ìƒ ë°ì´í„°
        const SHAPES = [
            { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: 'cyan' }, // I
            { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: 'blue' }, // J
            { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: 'orange' }, // L
            { shape: [[1, 1], [1, 1]], color: 'yellow' }, // O
            { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: 'lime' }, // S
            { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: 'purple' }, // T
            { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: 'red' } // Z
        ];

        // --- 2. í—¬í¼ í•¨ìˆ˜: ê·¸ë¦¬ê¸° ë° ì´ˆê¸°í™” ---

        function drawSquare(targetCtx, x, y, color, size = BLOCK_SIZE) {
            targetCtx.fillStyle = color;
            targetCtx.fillRect(x * size, y * size, size, size);
            targetCtx.strokeStyle = '#555';
            targetCtx.strokeRect(x * size, y * size, size, size);
        }

        function initBoard() {
            for (let r = 0; r < ROWS; r++) {
                board[r] = Array(COLS).fill(VACANT);
            }
        }

        function drawBoard() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    drawSquare(ctx, c, r, board[r][c]);
                }
            }
        }

        // --- 3. Piece í´ë˜ìŠ¤ ë° ìƒì„± ---

        class Piece {
            constructor(shapeData) {
                this.shape = shapeData.shape;
                this.color = shapeData.color;
                const offset = Math.floor((COLS - this.shape.length) / 2);
                this.x = offset;
                this.y = -Math.floor(this.shape.length / 2); 
            }

            draw(targetCtx) {
                this.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value) {
                            drawSquare(targetCtx, this.x + c, this.y + r, this.color);
                        }
                    });
                });
            }

            unDraw(targetCtx) {
                this.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value) {
                            drawSquare(targetCtx, this.x + c, this.y + r, VACANT);
                        }
                    });
                });
            }
        }

        function generateRandomPiece() {
            const random = Math.floor(Math.random() * SHAPES.length);
            return new Piece(SHAPES[random]);
        }

        function setupPieces() {
            currentPiece = generateRandomPiece();
            nextPiece = generateRandomPiece();
            drawNextPiece();
        }

        function drawNextPiece() {
            nextCtx.fillStyle = '#222';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            const scale = BLOCK_SIZE * 0.7;
            const offsetX = 0.5; 
            const offsetY = 0.5;

            nextPiece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        nextCtx.fillStyle = nextPiece.color;
                        nextCtx.fillRect(
                            (c + offsetX) * scale,
                            (r + offsetY) * scale,
                            scale,
                            scale
                        );
                        nextCtx.strokeStyle = '#555';
                        nextCtx.strokeRect(
                            (c + offsetX) * scale,
                            (r + offsetY) * scale,
                            scale,
                            scale
                        );
                    }
                });
            });
        }

        // --- 4. ì¶©ëŒ ê°ì§€ ë° ì´ë™ ë¡œì§ ---

        function checkCollision(nx, ny, shape) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c] === 0) continue;

                    const newX = currentPiece.x + c + nx;
                    const newY = currentPiece.y + r + ny;

                    // 1. ë²½ ë˜ëŠ” ë°”ë‹¥ê³¼ì˜ ì¶©ëŒ
                    if (newX < 0 || newX >= COLS || newY >= ROWS) {
                        return true;
                    }

                    // 2. ì´ë¯¸ ìŒ“ì¸ ë¸”ë¡ê³¼ì˜ ì¶©ëŒ
                    if (newY >= 0 && board[newY][newX] !== VACANT) {
                        return true;
                    }
                }
            }
            return false;
        }

        function move(nx, ny) {
            if (isGameOver) return false;
            if (!checkCollision(nx, ny, currentPiece.shape)) {
                currentPiece.unDraw(ctx);
                currentPiece.x += nx;
                currentPiece.y += ny;
                currentPiece.draw(ctx);
                return true;
            }
            return false;
        }

        function moveDown() {
            if (!move(0, 1)) {
                lockPiece();
            }
        }

        function hardDrop() {
            if (isGameOver) return;
            let dropCount = 0;
            while (move(0, 1)) {
                dropCount++;
            }
            score += dropCount * 2;
            scoreElement.innerText = score;
            lockPiece();
        }

        // --- 5. íšŒì „ ë¡œì§ ---

        function rotate() {
            if (isGameOver) return;
            let N = currentPiece.shape.length;
            let newShape = Array.from({ length: N }, () => Array(N).fill(0));

            // ì‹œê³„ ë°©í–¥ 90ë„ íšŒì „ ê³µì‹
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    newShape[c][N - 1 - r] = currentPiece.shape[r][c];
                }
            }

            // íšŒì „ í›„ ì¶©ëŒ ê²€ì‚¬
            if (!checkCollision(0, 0, newShape)) {
                currentPiece.unDraw(ctx);
                currentPiece.shape = newShape;
                currentPiece.draw(ctx);
            }
        }

        // --- 6. ë¸”ë¡ ê³ ì • ë° ì¤„ ì œê±° ---

        function lockPiece() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        const lockY = currentPiece.y + r;
                        const lockX = currentPiece.x + c;

                        if (lockY < 0) {
                            gameOver();
                            return;
                        }
                        board[lockY][lockX] = currentPiece.color;
                    }
                });
            });

            if (isGameOver) return;

            checkAndClearLines();
            drawBoard();

            currentPiece = nextPiece;
            nextPiece = generateRandomPiece();
            drawNextPiece();
        }

        function checkAndClearLines() {
            let linesCleared = 0;
            const scores = [0, 100, 300, 500, 800];

            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== VACANT)) {
                    linesCleared++;
                    for (let y = r; y > 0; y--) {
                        board[y] = board[y - 1];
                    }
                    board[0] = Array(COLS).fill(VACANT);
                    r++; // ì¤„ì´ ë‚´ë ¤ì™”ìœ¼ë¯€ë¡œ í˜„ì¬ ì¤„ì„ ë‹¤ì‹œ ê²€ì‚¬
                }
            }

            score += scores[linesCleared];
            scoreElement.innerText = score;
        }

        // --- 7. ê²Œì„ ë£¨í”„ ë° ì‹œì‘/ì¢…ë£Œ ---

        let animationId;
        function drop() {
            const now = Date.now();
            const delta = now - dropStart;

            if (delta > dropInterval) {
                moveDown();
                dropStart = Date.now();
            }

            if (!isGameOver) {
                animationId = requestAnimationFrame(drop);
            }
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationId);
            statusElement.style.display = 'block';
        }

        // --- 8. ì…ë ¥ ì²˜ë¦¬ (í‚¤ë³´ë“œ ë° ëª¨ë°”ì¼) ---

        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            switch (e.key) {
                case 'ArrowLeft': move(-1, 0); break;
                case 'ArrowRight': move(1, 0); break;
                case 'ArrowDown': move(0, 1); break;
                case 'ArrowUp': rotate(); break;
                case ' ': hardDrop(); break;
            }
        });

        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ì—°ê²°
        document.getElementById('btn-left').addEventListener('click', () => move(-1, 0));
        document.getElementById('btn-right').addEventListener('click', () => move(1, 0));
        document.getElementById('btn-rotate').addEventListener('click', rotate);
        document.getElementById('btn-hard-drop').addEventListener('click', hardDrop);

        // --- 9. ê²Œì„ ì´ˆê¸°í™” ë° ì‹¤í–‰ ---
        function startGame() {
            initBoard();
            drawBoard();
            setupPieces();
            drop();
        }

        startGame();
    </script>
</body>
</html>
